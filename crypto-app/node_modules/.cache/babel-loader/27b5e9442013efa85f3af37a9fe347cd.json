{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringify = void 0;\n\nconst stringify_1 = require(\"./stringify\");\n\nconst quote_1 = require(\"./quote\");\n/**\n * Root path node.\n */\n\n\nconst ROOT_SENTINEL = Symbol(\"root\");\n/**\n * Stringify any JavaScript value.\n */\n\nfunction stringify(value, replacer, indent) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const space = typeof indent === \"string\" ? indent : \" \".repeat(indent || 0);\n  const path = [];\n  const stack = new Set();\n  const tracking = new Map();\n  const unpack = new Map();\n  let valueCount = 0;\n  const {\n    maxDepth = 100,\n    references = false,\n    skipUndefinedProperties = false,\n    maxValues = 100000\n  } = options; // Wrap replacer function to support falling back on supported stringify.\n\n  const valueToString = replacerToString(replacer); // Every time you call `next(value)` execute this function.\n\n  const onNext = (value, key) => {\n    if (++valueCount > maxValues) return;\n    if (skipUndefinedProperties && value === undefined) return;\n    if (path.length > maxDepth) return; // An undefined key is treated as an out-of-band \"value\".\n\n    if (key === undefined) return valueToString(value, space, onNext, key);\n    path.push(key);\n    const result = builder(value, key === ROOT_SENTINEL ? undefined : key);\n    path.pop();\n    return result;\n  };\n\n  const builder = references ? (value, key) => {\n    if (value !== null && (typeof value === \"object\" || typeof value === \"function\" || typeof value === \"symbol\")) {\n      // Track nodes to restore later.\n      if (tracking.has(value)) {\n        unpack.set(path.slice(1), tracking.get(value)); // Use `undefined` as temporaray stand-in for referenced nodes\n\n        return valueToString(undefined, space, onNext, key);\n      } // Track encountered nodes.\n\n\n      tracking.set(value, path.slice(1));\n    }\n\n    return valueToString(value, space, onNext, key);\n  } : (value, key) => {\n    // Stop on recursion.\n    if (stack.has(value)) return;\n    stack.add(value);\n    const result = valueToString(value, space, onNext, key);\n    stack.delete(value);\n    return result;\n  };\n  const result = onNext(value, ROOT_SENTINEL); // Attempt to restore circular references.\n\n  if (unpack.size) {\n    const sp = space ? \" \" : \"\";\n    const eol = space ? \"\\n\" : \"\";\n    let wrapper = `var x${sp}=${sp}${result};${eol}`;\n\n    for (const [key, value] of unpack.entries()) {\n      const keyPath = quote_1.stringifyPath(key, onNext);\n      const valuePath = quote_1.stringifyPath(value, onNext);\n      wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;\n    }\n\n    return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;\n  }\n\n  return result;\n}\n\nexports.stringify = stringify;\n/**\n * Create `toString()` function from replacer.\n */\n\nfunction replacerToString(replacer) {\n  if (!replacer) return stringify_1.toString;\n  return (value, space, next, key) => {\n    return replacer(value, space, value => stringify_1.toString(value, space, next, key), key);\n  };\n}","map":{"version":3,"mappings":"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","names":["ROOT_SENTINEL","Symbol","stringify","value","replacer","indent","options","space","repeat","path","stack","Set","tracking","Map","unpack","valueCount","maxDepth","references","skipUndefinedProperties","maxValues","valueToString","replacerToString","onNext","key","undefined","length","push","result","builder","pop","has","set","slice","get","add","delete","size","sp","eol","wrapper","entries","keyPath","quote_1","valuePath","exports","stringify_1","next"],"sources":["/Users/isakgerre/Documents/GitHub/Crypto-Coin-Overview/crypto-app/node_modules/javascript-stringify/src/index.ts"],"sourcesContent":["import { toString } from \"./stringify\";\nimport { stringifyPath } from \"./quote\";\nimport { Next, ToString } from \"./types\";\n\nexport interface Options {\n  maxDepth?: number;\n  maxValues?: number;\n  references?: boolean;\n  skipUndefinedProperties?: boolean;\n}\n\n/**\n * Root path node.\n */\nconst ROOT_SENTINEL = Symbol(\"root\");\n\n/**\n * Stringify any JavaScript value.\n */\nexport function stringify(\n  value: any,\n  replacer?: ToString | null,\n  indent?: string | number | null,\n  options: Options = {}\n) {\n  const space = typeof indent === \"string\" ? indent : \" \".repeat(indent || 0);\n  const path: PropertyKey[] = [];\n  const stack = new Set();\n  const tracking = new Map<any, PropertyKey[]>();\n  const unpack = new Map<PropertyKey[], PropertyKey[]>();\n  let valueCount = 0;\n\n  const {\n    maxDepth = 100,\n    references = false,\n    skipUndefinedProperties = false,\n    maxValues = 100000,\n  } = options;\n\n  // Wrap replacer function to support falling back on supported stringify.\n  const valueToString = replacerToString(replacer);\n\n  // Every time you call `next(value)` execute this function.\n  const onNext: Next = (value, key) => {\n    if (++valueCount > maxValues) return;\n    if (skipUndefinedProperties && value === undefined) return;\n    if (path.length > maxDepth) return;\n\n    // An undefined key is treated as an out-of-band \"value\".\n    if (key === undefined) return valueToString(value, space, onNext, key);\n\n    path.push(key);\n    const result = builder(value, key === ROOT_SENTINEL ? undefined : key);\n    path.pop();\n    return result;\n  };\n\n  const builder: Next = references\n    ? (value, key) => {\n        if (\n          value !== null &&\n          (typeof value === \"object\" ||\n            typeof value === \"function\" ||\n            typeof value === \"symbol\")\n        ) {\n          // Track nodes to restore later.\n          if (tracking.has(value)) {\n            unpack.set(path.slice(1), tracking.get(value)!);\n            // Use `undefined` as temporaray stand-in for referenced nodes\n            return valueToString(undefined, space, onNext, key);\n          }\n\n          // Track encountered nodes.\n          tracking.set(value, path.slice(1));\n        }\n\n        return valueToString(value, space, onNext, key);\n      }\n    : (value, key) => {\n        // Stop on recursion.\n        if (stack.has(value)) return;\n\n        stack.add(value);\n        const result = valueToString(value, space, onNext, key);\n        stack.delete(value);\n        return result;\n      };\n\n  const result = onNext(value, ROOT_SENTINEL);\n\n  // Attempt to restore circular references.\n  if (unpack.size) {\n    const sp = space ? \" \" : \"\";\n    const eol = space ? \"\\n\" : \"\";\n    let wrapper = `var x${sp}=${sp}${result};${eol}`;\n\n    for (const [key, value] of unpack.entries()) {\n      const keyPath = stringifyPath(key, onNext);\n      const valuePath = stringifyPath(value, onNext);\n\n      wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;\n    }\n\n    return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;\n  }\n\n  return result;\n}\n\n/**\n * Create `toString()` function from replacer.\n */\nfunction replacerToString(replacer?: ToString | null): ToString {\n  if (!replacer) return toString;\n\n  return (value, space, next, key) => {\n    return replacer(\n      value,\n      space,\n      (value: any) => toString(value, space, next, key),\n      key\n    );\n  };\n}\n"]},"metadata":{},"sourceType":"script"}